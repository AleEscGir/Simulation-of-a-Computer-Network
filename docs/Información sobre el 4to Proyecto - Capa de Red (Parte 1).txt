Integrantes:
Alejandro Escobar Giraudy C312
Airelys Pérez Collazo C312

Este programa, confeccionado para la asignatura "Redes de Computadoras",
constituye el cuarto proyecto de la asignatura, el agrego de la capa de red,
los ip y los paquetes.

Lenguaje seleccionado: C#

En la orientación se nos pide que logremos confeccionarlo de forma tal que se puedan
declarar distintos dispositivos (en este caso solo PCs, Switchs o HUBs), conectarse entre sí
y enviarse información.

Claro, para la realización del código hemos tenido en cuenta las buenas prácticas
de programación implícitas de nuestra carrera, extensibilidad, legibilidad de código,
nombramiento correcto de variables y métodos, principios SOLID, entre otros.
Aclaro además que todo el código del programa está totalmente comentado en su ejecución
paso a paso, en caso de que se desee profundizar en alguna parte en específico.

Primeramente, puesto que es uno de los requisitos del proyecto, vamos a enumerar los cambios
que existen con respecto al proyecto anterior, y que demuestran la extensibilidad y
capacidad de adaptación a cambio del mismo. Esto se toma a modo de continuación del txt
del anterior proyecto.

Cambios generales:
-Fueron agregados los conceptos de paquete, ip y capa de red y fue modificado el comando de
mac para que reciba una de las entradas del dispositivo.
-El funcionamiento del envío de información fue modificado, ahora se pregunta si la PC
conoce un ip de un paquete a partir de un diccionario, si no lo conoce, debe utilizar
el ARP Quest para preguntar por dicho ip, el otro dispositivo lo recepciona, a partir
de modificaciones en la parte correspondiente al recibo de información,y reenvía lo necesario,
para que el primero complete todo y pueda enviar el paquete sin problemas, dentro de una
trama que recibe el cifrado, ahora en la PC.

Cambios Específicos:
-En Network fue modificado el comando mac, tal y como expresa la orden. Igualmente
fueron agregados los comandos ip y send_packet. ip simplemente le agrega un ip a una pc.
Por otro lado, de modo idéntico a como Network transformaba un Send_Frame en un Send, ahora
el comando Send_Packet es transformado en un Send_Frame, con la data pertinente.
-En Network fue modificado la transformación que se le impone de Send_Frame a Send.
Para ser exactos, en vez de utilizar los códigos del proyecto 3, serán usados los del proyecto
2, como consecuencia, a la PC le llegará una trama sin código de cifrado. Este cambio lo realizamos
ya que no tiene sentido cifrar una trama que no está completa (o sea, que carece del mac
al que queremos enviar la información), ahora este proceso ocurrirá dentro de PC.
-En PC cambia de nombre de un atributo, data_historial pasa a llamarse link_layer_historial, la razón
es sencilla, al ser agregados un historial por cada capa, es mejor que cada historial tenga bien
definido el nombre de la capa a la que corresponde. Igualmente se cambia el nombre del
método Link_Layer a Link_Layer_In, esto ocurre para diferenciar la transformación y las acciones
pertinentes que se le realizan a la información cuando llega o cuando se envñia información,
definido por las palabras In y Out, y del método Show_Historial_Data a Show_Link_Layer_Historial_Data,
por la misma razón por la que fue cambiado el nombre del atributo ya mencionado.
-En Pc son agregados los atributos ip, mask, ip_mac, arp_in, wait_time_arp, info_incomplete y
network_layer_historial. Igualmente son agregados los métodos Link_Layer_Out, Network_Layer_Out,
Arp_Quest, Network_Layer_In, Arp_Response, Show_Network_Layer_Historial_Data y Actualizate_IP_Mask.
-En Transformation_Codes fueron agregados los métodos Ip_To_Binary, Binary_To_Ip e Is_Binary.
-Fueron modificados el funcionamiento de los métodos de cifrado, ya que tuvieron que ser adaptados
a las grandes cantidades de información que generan los paquetes, que generaban números que excedían
el valor posible de los int.
-Fue modificado el método Link_Layer_In, antes llamado Link_Layer, ahora cuando se recibe toda la
información, se verifica si corresponde a un protoloco ARP de Quest o Response, en caso afirmativo
se actúa de forma recursiva con otros métodos para actuar en respuesta a la nueva información,
en caso negativo, la data es recepcionada como paquete y escrita en su correspondiente txt.

Como se puede apreciar los cambios fueron mínimos en el proyecto, casi en su totalidad
solo de agregos y no de modificación de lo ya existente.

Ahora comenzaré a hablar, a modo general, del funcionamiento del proyecto.

En el programa se pueden encontrar 7 clases principales:
-Device, una clase abstracta que encapsula cualquier tipo de dispositivo que se pueda
utilizar en la red
-PC, clase que hereda de Device y funciona según lo establecido en la orden del proyecto.
Puede enviar y recibir información, y posee solo un puerto.
-HUB, clase que hereda de Device y funciona según lo establecido en la orden del proyecto.
Tiene una cantidad variable de puertos, y si recibe información por uno de ellos, envía
dicha información por el resto de puertos.
-Switch, clase que hereda de Device y funciona según lo establecido en la orden del proyecto.
Tiene una cantidad variable de puertos, y envía la información a partir de las macs
que se encuentran en la misma.
-Network, esta clase funciona como la organizadora de la red. Recibe los parámetros del
script, ejecuta los comandos del mismo y controla el flujo de la red, desde qué dispositivo
debe enviar información para disminuir el número de colisiones, hasta actualizar el tiempo
actual de cada dispositivo.
-Transformation_Codes, guarda en ella los métodos que se encargan de la transformación de
números a decimal, binario y hexadecimal.
Data_Verification, funciona a modo de diccionario, donde con palabras claves devuelve
métodos de codificación.

A continuación detallaré los diferentes atributos y métodos utilizados por cada una de las clases.
Hago énfasis, para más detalles del funcionamiento, leer los comentarios en el código.

Device:

-public int last_actualization { get; protected set; }
 Muestra el tiempo en el que fue realizada la última actualización
        
-public string name { get; protected set; }
 Nombre del dispositivo
        
-protected List<string> historial { get; set; }
 Muestra el historial de bits enviados o recibidos, así como conexiones inválidas realizadas
        
-protected List<Device> devices { get; set; }
 Muestra los dispositivos a los que se conecta mediante un cable
        
-protected string info { get; set; }
 Muestra la información guardada actualmente en el dispositivo
        
-public bool already_sending { get; protected set; }
 Muestra si el dispositivo está realizando la acción de enviar información
        
-public bool already_receiving { get; protected set; }
 Muestra si el dispositivo está realizando la acción de recibir información

-public abstract void Receive_Info(string bit, int time, string sender)
 Define el cómo recibirá información el Dispositivo
        
-public abstract bool Actualization_Info(string information, int time)
 Define cómo actualizará la información el dispositivo
        
-public abstract bool Show_Info(string name)
 Muestra si el dispositivo le ha enviado alguna información al dispositivo remitente
                
-public abstract int Connect(Device device, int port)
 Conecta uno de los puertos del dispositivo a otro dispositivo
        
-public abstract int Disconnect(int port)
 Desconecta uno de los puertos del dispositivo
        
-public abstract int Device_Search(string name)
 Permite buscar un dispositivo en los puertos a partir de su nombre
        
-public abstract string Device_Search(int port)
 Permite buscar el nomrbe de un dispositivo a partir del puerto en el que se encuentra
        
-public abstract void Show_Historial(string directory)
 Muestra el historial de un dispositivo
        
-public abstract string[] Restart()
  Reinicia la información del dispositivo en caso de que ocurra un problema, y devuelve un array
  con las informaciones pertinentes

-public abstract void Receiving_Verification()
 Verifica si el dispositivo está recibiendo información por sus puertos
        

PC: Device

Además de implementar los métodos ya mencionados en Device, y utilizar sus atributos, posee
los siguientes atributos y métodos:

-private int actual_info { get; set; }
 Muestra el bit actual que se está enviando de una cadena completa de bits

-public string mac { get; private set; }
 Muestra el mac de la PC
        
-private List<string> link_layer_historial { get; set; }
 Muestra el historial de datos que ha llegado al dispositivo
        
-private string data { get; set; }
 Muestra la información actual de la capa de enlace

-private string error_detection { get; set; }
 Representa el método utilizado para detectar errores

-private string mask { get; set; }
 Muestra la máscara de la PC, guardado como un número binario de 32 bits
       
-private Dictionary<string, string> ip_mac { get; set; }
 Muestra todas las mac que han sido descubiertas mediante el ARP
        
-private string arp_in { get; set; }
 Guarda el protocolo ARP entrante, para luego responderlo
        
-private int wait_time_arp { get; set; }
 Muestra el tiempo de espera hasta notar que falló el protocolo ARP
        
-private string info_incomplete { get; set; }
 Aquí se almacena la información que aún no puede enviarse por falta de datos
        
-private List<string> network_layer_historial { get; set; }
 Muestra el historial de datos de la capa de enlace que ha llegado al dispositivo

-private void Link_Layer_In(string bit)
Método que transforma la información recibida de la capa física a la capa de enlace

-public void Show_Network_Layer_Historial_Data(string directory)
 Método para mostrar el historial de datos del Dispositivo, correspondiente a la Capa de Enlace

-public void Actualizate_Mac(string mac)
 Método para poder darle un mac a la PC

-public bool Can_Send()
 Verifica de antemano si el dispositivo creará una colisión al enviar información

-public void Link_Layer_Out(string new_mac = "")
 Método para procesar la información que será enviada, a modo de trama

-public void Network_Layer_Out(string information)
 Método que procesa la información que será enviada, a modo de paquete       

-public void ARP_Quest(string information)
 Método que prepara el dispositivo para enviar el ARP Quest

-private void Network_Layer_In(string data)
 Método que procesa la información de la capa de red que se encuentra en una trama de la capa de enlace

-public void ARP_Response(string information)
 Método que prepara el dispositivo para enviar el ARP Response

-public void Show_Network_Layer_Historial_Data(string directory)
 Método para mostrar el historial de datos del Dispositivo, correspondiente a la Capa de Enlace

-public void Actualizate_IP_Mask(string ip, string mask)
 Método para poder darle un ip y una mask a la PC
        


HUB: Device
Además de implementar los métodos ya mencionados en Device, y utilizar sus atributos,
solo implementa una sobrecarga del método Disconnect:

-public int Disconnect(string name)
 Método para desconectar la PC de otro dispositivo, mediante su nombre
        
Switch: Device
Además de implementar los métodos ya mencionados en Device, y utilizar sus atributos, posee
los siguientes atributos y métodos:

-private List<List<string>> known_mac { get; set; }
 Aquí se guardarán todas las mac que hasta ahora conoce el Switch

-private List<string> receiving_data { get; set; } 
 Aquí se guardará toda la información que está recibiendo cada puerto

-private List<Queue<string>> sending_data { get; set; }
 Aquí se guardará toda la información que debe transmitir un puerto

-private List<string> information { get; set; }
 Aquí se guardará la información que actualmente se está enviando por cada puerto

-public int Disconnect(string name)
 Método para desconectar un dispositivo de uno de los puertos, mediante su nombre

-public void Link_Layer(int pos)
 Método para decodificar la información y pasarla a la capa de enlace

-public int Search_Mac(string mac)
 Método para saber en cuál de las listas de macs se encuentra una mac


Network:

-private int time { get; set; }
 Representa el tiempo global de ejecución
        
-private int next_time { get; set; }
 Representa el próximo momento en el que se actualizarán todos los dispositivos
        
-private int signal_time { get; set; }
 Representa el interalo de tiempo entre una actualización y otra

-private string error_detection { get; set; }
 Representa el método utilizado para detectar errores
        
-private List<Device> devices { get; set; }
 Representa la lista de dispositivos activos
        
-private List<string[]> commands { get; set; }
 Representa los comandos del txt que aún no han podido ser ejecutados

-public void Inicialize_Network(string directory)
 Este método inicializa el funcionamiento de la red
        
-public void Execute_Order(string[] order)        
 Este método se encarga de ejecutar un comando
        
-public bool Already_Info()
 Este método muestra si alguno de los dispositivos de la red aún está trabajando
        
-public int Search(string name)        
 Este método, dado el nombre de un dispositivo, busca su posición en la lista
        
-public void Actualization()        
 Este método actualiza todos los dispositivos actuales
        
-public void Writer(string directory)        
 Este método hace a todos los dispositivos escribir su historial
        
-public void Execute_Possible_Commands()        
 Este método ejecuta de forma al azar los comandos que sean posible de entre los que no han sido ejecutados

Transformation_Codes:

-public static int Binary_to_Decimal(string binary)
 Método para transformar del lenguaje Binario al Decimal

-public static string Decimal_to_Binary(int value)
 Método para transformar del lenguaje Decimal al Binario
 
-public static int Hexadecimal_to_Decimal(string hexadecimal)
 Método para transformar del lenguaje Hexadecimal al Decimal

-public static string Decimal_to_Hexadecimal(int value)
 Método para transformar del lenguaje Decimal al Hexadecimal

-private static int Hexadecimal_to_Decimal_One_Bit(string hexadecimal)
 Método para transformar un bit del lenguaje Hexadecimal al Decimal

-private static string Decimal_to_Hexadecimal_One_Bit(int value)
 Método para transformar un bit del lenguaje Decimal al Hexadecimal

-public static string Binary_to_Hexadecimal(string binary)
 Método para transformar del lenguaje Binario al Hexadecimal

-public static string Hexadecimal_to_Binary(string hexadecimal)
 Método para transformar del lenguaje Hexadecimal al Binario

-public static string Add_Zero(string number, int length)
 Método para transformar Agregar ceros a la izquierda de un número

-public static string Ip_to_Binary(string ip)
Método para transformar un número de ip en un número binario de 32 bits        

-public static string Binary_to_Ip(string binary)
Método para transformar un número binario de 32 bits en un ip

-public static bool Is_Binary(string binary)
Método para comprobar si un número se encuentra en binario


Data_Verification:

-protected Dictionary<string, Func<string, string>> dictionary { get; set; }
 Diccionario que dado un string, devuelve una función de cifrado

-public string Evaluate(string data, string method)
 Método que dada una palabra devuelve un método de cifrado

-public void Set_Defaul_Values()
 Método que agrega al diccionario los dos métodos de cifrado por default

-public List<string> Keys()
 Método que devuelve todas las palabras claves para obtener los métodos de cifrado

-private static string Cuadratic_Codificator(string word)
 Método de Cifrado #1

-private static string Sum_Codificator(string word)
 Método de cifrado #2


Ya mencionados los métodos y atributos de las clases se puede dar una idea
del funcionamiento general del programa. Cada dispositivos tiene conocimiento
solo de su información, a quién enviarsela y cómo, pero no afecta directamente
a otros dispositivos ni a la red. Por otro lado, la red controla el orden de
comandos que debe ejecutar los dispositivos, pero más allá de organizar, no
afecta directamente a los dispositivos, para así mantener algunos de los
principios SOLID. No es posible modificar algún atributo de una clase si no
es a través de ella misma (o de sus hijos en el caso de la herencia) tampoco.

El proyecto a nivel físico de compone de 5 .cs:
-Network.cs, contiene la clase del mismo nombre
-Devices.cs, contiene las clases Device, PC, HUB y Switch
-Program.cs, procesa el txt y realiza la ejecución principal del programa
-Transformation_Device.cs, contiene una clase estática con distintas funcionalidades
-Data_Verification, contiene los métodos de cifrados que utilizan las PC

Sin más que decir, esperamos que sea de su agrado el proyecto.