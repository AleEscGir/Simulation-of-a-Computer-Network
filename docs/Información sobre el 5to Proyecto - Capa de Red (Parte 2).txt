Integrantes:
Alejandro Escobar Giraudy C312
Airelys Pérez Collazo C312

Este programa, confeccionado para la asignatura "Redes de Computadoras",
constituye el quinto proyecto de la asignatura, el agrego del router, las
tablas de rutas y el protocolo ICMP.

Lenguaje seleccionado: C#

En la orientación se nos pide que logremos confeccionarlo de forma tal que se puedan
declarar distintos dispositivos (en este caso solo PCs, Switchs, HUBs y Routers), conectarse entre sí
y enviarse información.

Claro, para la realización del código hemos tenido en cuenta las buenas prácticas
de programación implícitas de nuestra carrera, extensibilidad, legibilidad de código,
nombramiento correcto de variables y métodos, principios SOLID, entre otros.
Aclaro además que todo el código del programa está totalmente comentado en su ejecución
paso a paso, en caso de que se desee profundizar en alguna parte en específico.

Primeramente, puesto que es uno de los requisitos del proyecto, vamos a enumerar los cambios
que existen con respecto al proyecto anterior, y que demuestran la extensibilidad y
capacidad de adaptación a cambio del mismo. Esto se toma a modo de continuación del txt
del anterior proyecto.

Cambios generales:
-Fueron agreagadas las tablas de rutas, que le permite al dispositivo
ahora saber exactamente a quién debe enviar la información a partir de su ip,
o, ya sea directamente al destinatario de la información, o a un dispositivo
que medie entre ambos
-Fue agregado un nuevo dispositivo, el Router, que funciona parecido a los switch,
pero seleccionando el envío de información a partir de los ip, en vez de las macs.
-Fue agregado el protocolo ICMP, en este caso son 4 mensajes especiales que
se transportan entre los dispositivos.



Cambios Específicos:
-Fue agregada una clase Route, en Device.cs, que encapsula los conceptos
de destination, mask, gateway, port y priority, referentes a lo que conforman
las rutas.
-En Network, específicamente en Execute_Order, fue agregado el cómo 
procesar los nuevos comandos, add route, que agrega una ruta nueva
a un dispositivo, delete route, que elimina un ruta de un dispositivo,
route reset, que reinicia todas las rutas en el dispositivo, y
ping, que envía un mensaje especialde un dispositivo a otro.
Este último se logró convirtiendo a ping en un send_packet
-En Execute_Order igualmente, por extensibilidad, fueron modificadas
la forma de procesar a send_packet y send_frame, ahora, ahora depende de
si la información ya ha sido procesada por los anteriores comandos, para
evitar inconsistencias en las transformaciones del lenguaje hexadecimal
a binario.
-En Transformation Codes fueron modificados los métodos Binary_to_Hexadecimal
y Hexadecimal_to_Binary, ahora transforman directamente de uno a otro, sin pasar
por el formato decimal, puesto que los int de C# no eran capaces de
guardar los grandes volúmenes de información que tiene una trama actualmente.
-Fue agregada el Router, con todos sus métodos y atributos correspondientes.
Este en resumen, fue hecho con el código de Switch, cambiando solamente
la forma de procesar la información entrante, para analizar la información
y su envío a partir de los ip. Igualmente para procesar esta información
fue utilizado un código muy similar al que utiliza PC para procesar la capa de
red, así como el envío y recibo de ARPQ y ARPR.
-En PC fue agregado el cómo procesar el envío y recibo de ping, pong, y
destination host unreachable, directamente en el método Actualization_Info,
sin necesidad de modificar las capas superiores. Fueron agregado para ello
el método Pong_Response.
-En PC y Router se utiliza el método Route_Selector, que permite elegir a
qué ruta será enviada la información según la tabla de ruta. Así mismo se
pueden encontrar para el recibo y eliminación de rutas los métodos Add_Route
y Delete_Route.
-Fue agregado como parámetro de entrada a PC el signal_time, para el envío
de los ping.
-En PC, ahora arp_in se convierte en una cola, para permitir el recibo de
varios ARPQ a la vez. En este caso, la cola guarda los distintos ARPR que
el dispositivo debe envir.



Como se puede apreciar los cambios fueron mínimos en el proyecto, casi en su totalidad
solo de agregos y no de modificación de lo ya existente.

Ahora comenzaré a hablar, a modo general, del funcionamiento del proyecto.

En el programa se pueden encontrar 9 clases principales:
-Device, una clase abstracta que encapsula cualquier tipo de dispositivo que se pueda
utilizar en la red
-PC, clase que hereda de Device y funciona según lo establecido en la orden del proyecto.
Puede enviar y recibir información, y posee solo un puerto.
-HUB, clase que hereda de Device y funciona según lo establecido en la orden del proyecto.
Tiene una cantidad variable de puertos, y si recibe información por uno de ellos, envía
dicha información por el resto de puertos.
-Switch, clase que hereda de Device y funciona según lo establecido en la orden del proyecto.
Tiene una cantidad variable de puertos, y envía la información a partir de las macs
que se encuentran en la misma.
-Router, clase que hereda de Device y funciona según lo establecido en la orden del proyecto.
Tiene una cantidad variable, y envía la información, así como ARPQ y ARPR, a partir
de los ip que se encuentra en la tabla de rutas.
-Network, esta clase funciona como la organizadora de la red. Recibe los parámetros del
script, ejecuta los comandos del mismo y controla el flujo de la red, desde qué dispositivo
debe enviar información para disminuir el número de colisiones, hasta actualizar el tiempo
actual de cada dispositivo.
-Transformation_Codes, guarda en ella los métodos que se encargan de la transformación de
números a decimal, binario y hexadecimal.
-Data_Verification, funciona a modo de diccionario, donde con palabras claves devuelve
métodos de codificación.
-Route, encapsula los conceptos referentes a las rutas, descritos en el proyecto.

A continuación detallaré los diferentes atributos y métodos utilizados por cada una de las clases.
Hago énfasis, para más detalles del funcionamiento, leer los comentarios en el código.

Device:

-public int last_actualization { get; protected set; }
 Muestra el tiempo en el que fue realizada la última actualización
        
-public string name { get; protected set; }
 Nombre del dispositivo
        
-protected List<string> historial { get; set; }
 Muestra el historial de bits enviados o recibidos, así como conexiones inválidas realizadas
        
-protected List<Device> devices { get; set; }
 Muestra los dispositivos a los que se conecta mediante un cable
        
-protected string info { get; set; }
 Muestra la información guardada actualmente en el dispositivo
        
-public bool already_sending { get; protected set; }
 Muestra si el dispositivo está realizando la acción de enviar información
        
-public bool already_receiving { get; protected set; }
 Muestra si el dispositivo está realizando la acción de recibir información

-public abstract void Receive_Info(string bit, int time, string sender)
 Define el cómo recibirá información el Dispositivo
        
-public abstract bool Actualization_Info(string information, int time)
 Define cómo actualizará la información el dispositivo
        
-public abstract bool Show_Info(string name)
 Muestra si el dispositivo le ha enviado alguna información al dispositivo remitente
                
-public abstract int Connect(Device device, int port)
 Conecta uno de los puertos del dispositivo a otro dispositivo
        
-public abstract int Disconnect(int port)
 Desconecta uno de los puertos del dispositivo
        
-public abstract int Device_Search(string name)
 Permite buscar un dispositivo en los puertos a partir de su nombre
        
-public abstract string Device_Search(int port)
 Permite buscar el nomrbe de un dispositivo a partir del puerto en el que se encuentra
        
-public abstract void Show_Historial(string directory)
 Muestra el historial de un dispositivo
        
-public abstract string[] Restart()
  Reinicia la información del dispositivo en caso de que ocurra un problema, y devuelve un array
  con las informaciones pertinentes

-public abstract void Receiving_Verification()
 Verifica si el dispositivo está recibiendo información por sus puertos



Route:

-public string destination { get; private set; }
 Indica el campo destino de una ruta

-public string mask { get; private set; }
 Indica la máscara que utilizará la ruta
        
-public string gateway { get; private set; }
 Indica a qué dispositivo se le enviará la información
        
-public int interface_port { get; private set; }
 Indica el puerto por el que será enviada la información
        
-public int priority { get; private set; }
 Indica la cantidad de 1s en la máscara, que será la prioridad de la misma
        

PC: Device

Además de implementar los métodos ya mencionados en Device, y utilizar sus atributos, posee
los siguientes atributos y métodos:

-private int actual_info { get; set; }
 Muestra el bit actual que se está enviando de una cadena completa de bits

-public string mac { get; private set; }
 Muestra el mac de la PC
        
-private List<string> link_layer_historial { get; set; }
 Muestra el historial de datos que ha llegado al dispositivo
        
-private string data { get; set; }
 Muestra la información actual de la capa de enlace

-private string error_detection { get; set; }
 Representa el método utilizado para detectar errores

-public string ip { get; private set; }
 Muestra el ip de la PC, guardado como un número binario de 32 bits

-private string mask { get; set; }
 Muestra la máscara de la PC, guardado como un número binario de 32 bits
       
-private Dictionary<string, string> ip_mac { get; set; }
 Muestra todas las mac que han sido descubiertas mediante el ARP
        
-private Queue<string> arp_in { get; set; }
 Guarda los ARP Response que están listos para ser enviados
                
-private int wait_time_arp { get; set; }
 Muestra el tiempo de espera hasta notar que falló el protocolo ARP
        
-private string info_incomplete { get; set; }
 Aquí se almacena la información que aún no puede enviarse por falta de datos
        
-private List<string> network_layer_historial { get; set; }
 Muestra el historial de datos de la capa de enlace que ha llegado al dispositivo

-private void Link_Layer_In(string bit)
 Método que transforma la información recibida de la capa física a la capa de enlace

-private List<Route> routes { get; set; }
 Aquí se guardarán todas las rutas que contiene el Router

-private int time_ping { get; set; }
 Aquí se guarda el intervalo entre cada uno de los ping
        
-private int number_of_pins { get; set; }
 Aquí se guarda la cantidad de ping seguidos que han sido enviados
        
-private Queue<string> wait_pong { get; set; }
 Aquí se guardan todos los pong que están listos para ser enviados
        
-private int interval { get; set; }
 Aquí se guarda el intervalo de tiempo entre cada actualización





-public void Show_Network_Layer_Historial_Data(string directory)
 Método para mostrar el historial de datos del Dispositivo, correspondiente a la Capa de Enlace

-public void Actualizate_Mac(string mac)
 Método para poder darle un mac a la PC

-public bool Can_Send()
 Verifica de antemano si el dispositivo creará una colisión al enviar información

-public void Link_Layer_Out(string new_mac = "")
 Método para procesar la información que será enviada, a modo de trama

-public void Network_Layer_Out(string information)
 Método que procesa la información que será enviada, a modo de paquete       

-public void ARP_Quest(string information)
 Método que prepara el dispositivo para enviar el ARP Quest

-public string Route_Selector(string receptor_ip)
 Método para analizar a qué dispositivo se debe enviar la información a partir
 de las tablas de turas

-private void Network_Layer_In(string data)
 Método que procesa la información de la capa de red que se encuentra en una trama de la capa de enlace

-public void ARP_Response(string information)
 Método que prepara el dispositivo para enviar el ARP Response

-public void Pong_Response()
 Método que prepara el dispositivo para responder un pong a partir de un ping

-public void Show_Network_Layer_Historial_Data(string directory)
 Método para mostrar el historial de datos del Dispositivo, correspondiente a la Capa de Enlace

-public void Actualizate_IP_Mask(string ip, string mask)
 Método para poder darle un ip y una mask a la PC

-public void Add_Route(string destination, string mask, string gateway, int interface_port)        
 Método que añade una ruta a la lista de rutas

-public void Delete_Route(string destination, string mask, string gateway, int interface_port)
 Método que elimina una ruta a la lista de rutas



HUB: Device
Además de implementar los métodos ya mencionados en Device, y utilizar sus atributos,
solo implementa una sobrecarga del método Disconnect:

-public int Disconnect(string name)
 Método para desconectar la PC de otro dispositivo, mediante su nombre

        
Switch: Device
Además de implementar los métodos ya mencionados en Device, y utilizar sus atributos, posee
los siguientes atributos y métodos:

-private List<List<string>> known_mac { get; set; }
 Aquí se guardarán todas las mac que hasta ahora conoce el Switch

-private List<string> receiving_data { get; set; } 
 Aquí se guardará toda la información que está recibiendo cada puerto

-private List<Queue<string>> sending_data { get; set; }
 Aquí se guardará toda la información que debe transmitir un puerto

-private List<string> information { get; set; }
 Aquí se guardará la información que actualmente se está enviando por cada puerto

-public int Disconnect(string name)
 Método para desconectar un dispositivo de uno de los puertos, mediante su nombre

-public void Link_Layer(int pos)
 Método para decodificar la información y pasarla a la capa de enlace

-public int Search_Mac(string mac)
 Método para saber en cuál de las listas de macs se encuentra una mac


Router: Device
Además de implementar los métodos ya mencionados en Device, y utilizar sus atributos, posee
los siguientes atributos y métodos:

-private string error_detection { get; set; }
 Aquí se guarda el verificador de erorres que se está usando

-private List<Route> routes { get; set; }
 Aquí se guardarán todas las rutas que contiene el Router

-private List<string> receiving_data { get; set; }
 Aquí se guardará toda la información que está recibiendo cada puerto

-private List<Queue<string>> sending_data { get; set; }
 Aquí se guardará toda la información que debe transmitir un puerto

-private List<string> information { get; set; }
 Aquí se guardará el bit que actualmente se está enviando por cada puerto

-private List<string> ip_list { get; set; }
 Aquí se guardará una lista que contiene el ip de cada interfaz

-private List<string> mask_list { get; set; }
 Aquí se guardará una lista que contiene la máscara de cada interfaz

-private List<string> mac_list { get; set; }
 Aquí se guardará una lista que contiene la mac de cada interfaz

-private List<Queue<string>> info_waiting_arp { get; set; }
 Aquí se guardará toda información que todavía no puede ser enviada por falta de ARP Response

-private Dictionary<string, string> ip_mac { get; set; }
 Diccionario que muestra todas las mac que han sido descubiertas mediante el ARP

-private List<int> wait_time_arp { get; set; }
 Muestra el tiempo de espera de cada intefaz hasta notar que falló el protocolo ARP

-public void Link_Layer(int pos)
 Método para decodificar la información y pasarla a la capa de enlace

-public void Network_Layer(string info)
 Método que procesa la información recibida, a modo de paquete, y decide
 por qué puerto será enviada

-public Tuple<string, int> Route_Selector(string receptor_ip)
 Método para analizar a qué dispositivo se debe enviar la información a partir
 de las tablas de rutas, devuelve el ip receptor y el puerto

-public void ARP_Response(string data, int pos)
 Método que prepara el dispositivo para enviar el ARP Response

-public void ARP_Quest(int pos)        
 Método que prepara el dispositivo para enviar el ARP Quest

-public void DHU_Response(string info)
 Método para responderle a un dispositivo un destination host unreachable

-public int Disconnect(string name)
 Método para desconectar un dispositivo de uno de los puertos, mediante su nombre

-public void Actualizate_Mac(string mac, int port)
 Método para poder darle una mac a una de las interfaces del Router

-public void Actualizate_IP_Mask(string ip, string mask, int port)
 Método para poder darle un ip y una mask a una interfaz del Router

-public void Add_Route(string destination, string mask, string gateway, int interface_port)
 Método que añade una ruta a la lista de rutas

-public void Delete_Route(string destination, string mask, string gateway, int interface_port)
 Método que elimina una ruta a la lista de rutas



Network:

-private int time { get; set; }
 Representa el tiempo global de ejecución
        
-private int next_time { get; set; }
 Representa el próximo momento en el que se actualizarán todos los dispositivos
        
-private int signal_time { get; set; }
 Representa el interalo de tiempo entre una actualización y otra

-private string error_detection { get; set; }
 Representa el método utilizado para detectar errores
        
-private List<Device> devices { get; set; }
 Representa la lista de dispositivos activos
        
-private List<string[]> commands { get; set; }
 Representa los comandos del txt que aún no han podido ser ejecutados

-public void Inicialize_Network(string directory)
 Este método inicializa el funcionamiento de la red
        
-public void Execute_Order(string[] order)        
 Este método se encarga de ejecutar un comando
        
-public bool Already_Info()
 Este método muestra si alguno de los dispositivos de la red aún está trabajando
        
-public int Search(string name)        
 Este método, dado el nombre de un dispositivo, busca su posición en la lista
        
-public void Actualization()        
 Este método actualiza todos los dispositivos actuales
        
-public void Writer(string directory)        
 Este método hace a todos los dispositivos escribir su historial
        
-public void Execute_Possible_Commands()        
 Este método ejecuta de forma al azar los comandos que sean posible de entre los que no han sido ejecutados



Transformation_Codes:

-public static int Binary_to_Decimal(string binary)
 Método para transformar del lenguaje Binario al Decimal

-public static string Decimal_to_Binary(int value)
 Método para transformar del lenguaje Decimal al Binario
 
-public static int Hexadecimal_to_Decimal(string hexadecimal)
 Método para transformar del lenguaje Hexadecimal al Decimal

-public static string Decimal_to_Hexadecimal(int value)
 Método para transformar del lenguaje Decimal al Hexadecimal

-private static int Hexadecimal_to_Decimal_One_Bit(string hexadecimal)
 Método para transformar un bit del lenguaje Hexadecimal al Decimal

-private static string Decimal_to_Hexadecimal_One_Bit(int value)
 Método para transformar un bit del lenguaje Decimal al Hexadecimal

-public static string Binary_to_Hexadecimal(string binary)
 Método para transformar del lenguaje Binario al Hexadecimal

-public static string Hexadecimal_to_Binary(string hexadecimal)
 Método para transformar del lenguaje Hexadecimal al Binario

-public static string Add_Zero(string number, int length)
 Método para transformar Agregar ceros a la izquierda de un número

-public static string Ip_to_Binary(string ip)
Método para transformar un número de ip en un número binario de 32 bits        

-public static string Binary_to_Ip(string binary)
Método para transformar un número binario de 32 bits en un ip

-public static bool Is_Binary(string binary)
Método para comprobar si un número se encuentra en binario


Data_Verification:

-protected Dictionary<string, Func<string, string>> dictionary { get; set; }
 Diccionario que dado un string, devuelve una función de cifrado

-public string Evaluate(string data, string method)
 Método que dada una palabra devuelve un método de cifrado

-public void Set_Defaul_Values()
 Método que agrega al diccionario los dos métodos de cifrado por default

-public List<string> Keys()
 Método que devuelve todas las palabras claves para obtener los métodos de cifrado

-private static string Cuadratic_Codificator(string word)
 Método de Cifrado #1

-private static string Sum_Codificator(string word)
 Método de cifrado #2


Ya mencionados los métodos y atributos de las clases se puede dar una idea
del funcionamiento general del programa. Cada dispositivos tiene conocimiento
solo de su información, a quién enviarsela y cómo, pero no afecta directamente
a otros dispositivos ni a la red. Por otro lado, la red controla el orden de
comandos que debe ejecutar los dispositivos, pero más allá de organizar, no
afecta directamente a los dispositivos, para así mantener algunos de los
principios SOLID. No es posible modificar algún atributo de una clase si no
es a través de ella misma (o de sus hijos en el caso de la herencia) tampoco.

El proyecto a nivel físico de compone de 5 .cs:
-Network.cs, contiene la clase del mismo nombre
-Devices.cs, contiene las clases Device, PC, HUB y Switch
-Program.cs, procesa el txt y realiza la ejecución principal del programa
-Transformation_Device.cs, contiene una clase estática con distintas funcionalidades
-Data_Verification, contiene los métodos de cifrados que utilizan las PC

Sin más que decir, esperamos que sea de su agrado el proyecto.